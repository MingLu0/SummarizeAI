package com.summarizeai.integration

import com.summarizeai.data.local.datasource.SummaryLocalDataSource
import com.summarizeai.data.local.preferences.UserPreferences
import com.summarizeai.data.model.StreamingResult
import com.summarizeai.data.model.SummaryData
import com.summarizeai.data.remote.api.StreamChunk
import com.summarizeai.data.remote.api.StreamingSummarizerService
import com.summarizeai.data.remote.datasource.SummaryRemoteDataSource
import com.summarizeai.data.repository.SummaryRepositoryImpl
import com.summarizeai.presentation.viewmodel.HomeViewModel
import com.summarizeai.presentation.viewmodel.SettingsViewModel
import com.summarizeai.utils.ErrorHandler
import com.summarizeai.utils.TextExtractionUtils
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.test.runTest
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.mockito.kotlin.*

class StreamingIntegrationTest {

    private lateinit var mockStreamingService: StreamingSummarizerService
    private lateinit var mockRemoteDataSource: SummaryRemoteDataSource
    private lateinit var mockLocalDataSource: SummaryLocalDataSource
    private lateinit var mockUserPreferences: UserPreferences
    private lateinit var mockErrorHandler: ErrorHandler
    private lateinit var mockTextExtractionUtils: TextExtractionUtils
    private lateinit var repository: SummaryRepositoryImpl
    private lateinit var homeViewModel: HomeViewModel
    private lateinit var settingsViewModel: SettingsViewModel

    @Before
    fun setup() {
        mockStreamingService = mock()
        mockRemoteDataSource = mock()
        mockLocalDataSource = mock()
        mockUserPreferences = mock()
        mockErrorHandler = mock()
        mockTextExtractionUtils = mock()
        
        repository = SummaryRepositoryImpl(
            mockRemoteDataSource,
            mockLocalDataSource,
            mockStreamingService
        )
        
        homeViewModel = HomeViewModel(
            repository,
            mockTextExtractionUtils,
            mockErrorHandler,
            mockUserPreferences
        )
        
        settingsViewModel = SettingsViewModel(mockUserPreferences)
    }

    @Test
    fun `full streaming flow should work end-to-end`() = runTest {
        // Given
        val testText = "This is a test. This is another sentence! And a final one?"
        val chunks = listOf(
            StreamChunk("This is a", false),
            StreamChunk(" test.", false),
            StreamChunk(" This is another", false),
            StreamChunk(" sentence!", false),
            StreamChunk(" And a final one?", true)
        )
        
        whenever(mockUserPreferences.isStreamingEnabled).thenReturn(flowOf(true))
        whenever(mockStreamingService.streamSummary(eq(testText), any())).thenReturn(flowOf(*chunks.toTypedArray()))

        // When - User enables streaming in settings
        settingsViewModel.setStreamingEnabled(true)
        
        // When - User starts summarization
        homeViewModel.updateTextInput(testText)
        homeViewModel.summarizeText()

        // Then - Verify streaming service is called
        verify(mockStreamingService).streamSummary(eq(testText), any())
        
        // Then - Verify repository processes streaming results
        val results = repository.summarizeTextStreaming(testText).first()
        assertTrue(results is StreamingResult.Complete)
        
        val summaryData = (results as StreamingResult.Complete).summaryData
        assertEquals(testText, summaryData.originalText)
        assertTrue(summaryData.mediumSummary.contains("This is a test"))
        assertTrue(summaryData.mediumSummary.contains("This is another sentence"))
        assertTrue(summaryData.mediumSummary.contains("And a final one"))
    }

    @Test
    fun `streaming preference toggle should affect behavior`() = runTest {
        // Given
        val testText = "Test text"
        
        // When streaming is enabled
        whenever(mockUserPreferences.isStreamingEnabled).thenReturn(flowOf(true))
        whenever(mockStreamingService.streamSummary(eq(testText), any())).thenReturn(flowOf())
        
        homeViewModel.updateTextInput(testText)
        homeViewModel.summarizeText()
        
        // Then streaming service should be called
        verify(mockStreamingService).streamSummary(eq(testText), any())
        verify(mockRemoteDataSource, never()).summarizeText(any())
        
        // Reset mocks
        reset(mockStreamingService, mockRemoteDataSource)
        
        // When streaming is disabled
        whenever(mockUserPreferences.isStreamingEnabled).thenReturn(flowOf(false))
        whenever(mockRemoteDataSource.summarizeText(any())).thenReturn(
            com.summarizeai.data.model.ApiResult.Success(
                com.summarizeai.data.remote.api.SummarizeResponse("Summary", "model", 100, 1500)
            )
        )
        
        homeViewModel.updateTextInput(testText)
        homeViewModel.summarizeText()
        
        // Then traditional API should be called
        verify(mockRemoteDataSource).summarizeText(any())
        verify(mockStreamingService, never()).streamSummary(any(), any())
    }

    @Test
    fun `streaming should handle errors gracefully and fallback`() = runTest {
        // Given
        val testText = "Test text"
        val errorMessage = "Streaming failed"
        
        whenever(mockUserPreferences.isStreamingEnabled).thenReturn(flowOf(true))
        whenever(mockStreamingService.streamSummary(eq(testText), any())).thenThrow(
            Exception(errorMessage)
        )

        // When
        homeViewModel.updateTextInput(testText)
        homeViewModel.summarizeText()

        // Then
        verify(mockErrorHandler).showErrorToast(errorMessage)
        
        val uiState = homeViewModel.uiState.first()
        assertFalse(uiState.isStreaming)
        assertEquals(errorMessage, uiState.error)
    }

    @Test
    fun `settings viewmodel should persist streaming preference`() = runTest {
        // Given
        whenever(mockUserPreferences.setStreamingEnabled(true)).thenReturn(Unit)
        whenever(mockUserPreferences.setStreamingEnabled(false)).thenReturn(Unit)

        // When
        settingsViewModel.setStreamingEnabled(true)
        settingsViewModel.setStreamingEnabled(false)

        // Then
        verify(mockUserPreferences).setStreamingEnabled(true)
        verify(mockUserPreferences).setStreamingEnabled(false)
    }

    @Test
    fun `repository should save streaming results to database`() = runTest {
        // Given
        val testText = "Test text"
        val chunks = listOf(StreamChunk("Test summary.", true))
        
        whenever(mockStreamingService.streamSummary(eq(testText), any())).thenReturn(flowOf(*chunks.toTypedArray()))

        // When
        repository.summarizeTextStreaming(testText).first()

        // Then
        verify(mockLocalDataSource).insertSummary(any())
    }

    @Test
    fun `streaming should emit progress events for complete sentences`() = runTest {
        // Given
        val testText = "First sentence. Second sentence! Third sentence?"
        val chunks = listOf(
            StreamChunk("First sentence.", false),
            StreamChunk(" Second sentence!", false),
            StreamChunk(" Third sentence?", true)
        )
        
        whenever(mockStreamingService.streamSummary(eq(testText), any())).thenReturn(flowOf(*chunks.toTypedArray()))

        // When
        val results = repository.summarizeTextStreaming(testText).toList()

        // Then
        assertEquals(4, results.size) // 3 Progress + 1 Complete
        
        assertTrue(results[0] is StreamingResult.Progress)
        assertEquals("First sentence.", (results[0] as StreamingResult.Progress).text)
        
        assertTrue(results[1] is StreamingResult.Progress)
        assertEquals("Second sentence!", (results[1] as StreamingResult.Progress).text)
        
        assertTrue(results[2] is StreamingResult.Progress)
        assertEquals("Third sentence?", (results[2] as StreamingResult.Progress).text)
        
        assertTrue(results[3] is StreamingResult.Complete)
    }

    @Test
    fun `home viewmodel should update UI state during streaming`() = runTest {
        // Given
        val testText = "Test text"
        val streamingResults = listOf(
            StreamingResult.Progress("First part."),
            StreamingResult.Progress("Second part."),
            StreamingResult.Complete(
                SummaryData(
                    id = "test-id",
                    originalText = testText,
                    shortSummary = "Short",
                    mediumSummary = "First part. Second part.",
                    detailedSummary = "Detailed",
                    createdAt = java.util.Date(),
                    isSaved = false
                )
            )
        )
        
        whenever(mockUserPreferences.isStreamingEnabled).thenReturn(flowOf(true))
        whenever(mockStreamingService.streamSummary(eq(testText), any())).thenReturn(flowOf(*streamingResults.toTypedArray()))

        // When
        homeViewModel.updateTextInput(testText)
        homeViewModel.summarizeText()

        // Then
        val uiState = homeViewModel.uiState.first()
        assertTrue(uiState.isStreaming)
        assertEquals("Second part.", uiState.streamingProgress)
        assertNotNull(uiState.summaryData)
    }
}
